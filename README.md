# Объяснение поведения `defer` в Go: именованные vs локальные возвращаемые значения

В этом примере демонстрируется ключевое различие в поведении `defer` в Go, когда возвращаемое значение **именованное** (`test()`) и когда нет (`anotherTest()`).

---

## Код программы

```go
package main

import "fmt"

func test() (x int) {
  defer func() {
    x++
  }()
  x = 1
  return
}

func anotherTest() int {
  var x int
  defer func() {
    x++
  }()
  x = 1
  return x
}

func main() {
  fmt.Println(test())       // Вывод: 2
  fmt.Println(anotherTest()) // Вывод: 1
}
```

---

## Как работает `defer`?

- `defer` откладывает выполнение функции до момента **завершения** текущей функции.
- `defer` выполняется **после** вычисления возвращаемого значения, но **до** выхода из функции.
- **Ключевое отличие** - тип возвращаемого значения: **именованный** или **неименованный**.

---

## Разбор функций

### Функция `test()`

```go
func test() (x int) { // x - именованный возвращаемый параметр
  defer func() {
    x++               // Изменяет сам возвращаемый параметр
  }()
  x = 1
  return              // Возвращает x (который ещё не "запечатан")
}
```

- Здесь `x` - **именованный возвращаемый параметр**. Это означает, что `x` уже объявлен в области видимости функции и автоматически возвращается при `return`.
- Сначала `x` становится равным `1`.
- Затем срабатывает `return`, но перед тем, как функция завершится, **выполняется defer**.
- В defer `x++` увеличивает `x` на 1. То есть `x` становится равным `2`.
- Значение `x` (равное `2`) возвращается из функции.

> ✅ **Вывод: `2`**

---

### `anotherTest()`: Локальная переменная

```go
func anotherTest() int {  // Возвращаемое значение — неименованное
  var x int
  defer func() {
    x++                  // Изменяет локальную переменную, НЕ возвращаемое значение
  }()
  x = 1
  return x               // Здесь return "запечатал" значение 1
}
```
- Здесь `x` - обычная локальная переменная.
- `return x` **копирует текущее значение `x`** (`1`) в место возврата.
- **После этого** выполняется `defer`, и `x++` меняет **локальную переменную**, но **не влияет** на уже скопированное возвращаемое значение.
- Таким образом, возвращается `1`.

> ✅ **Вывод: `1`**

---

### ✅ **Итоговый вывод программы:**

```
2
1
```

---

### Краткое объяснение:

- `defer` функции выполняются **после** того, как вычислено возвращаемое значение, но **до** завершения функции.
- Если возвращаемый тип **именованный**, как в `test()`, то изменения, произошедшие в `defer`, **повлияют на возвращаемое значение**.
- Если возвращаемый тип **неименованный**, как в `anotherTest()`, то `defer` **не повлияет** на него, даже если изменяет локальную переменную, имеющую то же имя, что и переменная, возвращаемая через return. 